---
title: "对比模型"
author: "Yan Ren"
date: "2024-02-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggplot2)
library(dplyr)
library(Matrix)
library(flexmix)
library(readr)
library(ncvreg) # for linear regression with MCP penalty
library(cluster) # for k-means's determination about k
source("sim.R")
source("tools.R")
source("func.R")
```


# 对比实验

```{r}
n <- 500
p <- 80
q <- 40
epsilon_sd <- 0.5
epsilon_sd_init <- 0.5
sigma_est <- as.numeric(epsilon_sd_init)
balance <- 3
signal_size <- 1
beta_vlen <- 3
alpha_vlen <- 2
save_path <- "temp.csv"
dt_seed <- 9
K_up <- 4  # 估计时的最大类别，应该不少于 group_num_sub

cotype_x <- "En"
cotype_z <- "En"
beta_nonzero <- c(-2, -2, 2, 2)*signal_size # 长度应和真实 group_num_sub 保持一致
alpha_nonzero <- c(-3, -1, 1, 3)*signal_size

q_c_seed_max <- 10
group_num_main <- 2                    
group_num_sub <- 4    
hier_struc <- list(c(1,2),c(3,4))
# prob_sub <- rep(1/group_num_sub, group_num_sub)  
if(balance == 1){
  prob_sub <- rep(1/group_num_sub, group_num_sub)
}else if(balance == 2){
  prob_sub<-c(1/6,1/6,1/3,1/3)
}else{
  prob_sub<-c(1/6,1/3,1/6,1/3)
}
reverse <- FALSE

whole.data <- generate_all_data(dt_seed, n, p, q, prob_sub, hier_struc, 
                                beta_nonzero, alpha_nonzero, beta_vlen, alpha_vlen, 
                                cotype_x, cotype_z, epsilon_sd, reverse)
X <- whole.data$data$X
Z <- whole.data$data$Z
data <- whole.data$data$data_full
coef <- whole.data$coef
# coefv <- lapply(coef, as.vector) # 按照类别拉长
ci_sim <- whole.data$ci_sim
ci_sim_main <- whole.data$ci_sim_main
ci_sim_sub <- whole.data$ci_sim_sub
y <- matrix(whole.data$y, ncol=1)

# =============================== prepare =================================
comb_pair <- combn(K_up, 2)
H_p <- kronecker(t(apply(comb_pair, 2, get_e_mat, K_up)),
                 diag(p)) %>% Matrix(sparse = TRUE)
H_q <- kronecker(t(apply(comb_pair, 2, get_e_mat, K_up)),
                 diag(q)) %>% Matrix(sparse = TRUE)


# =============================== result =================================
colnames_part <- c("dt_seed", "q_c_seed", "tag", "mse", 
                   "cdist_main", "cdist_sub", "ci_prob_mean",
                  "sc", "sc_main", "sc_sub","ari", "ari_main", "ari_sub",
                  "main_grn", "sub_grn", "pi_est","group_detail")
```



## FRM1

和主实验中几乎一样

```{r}
FMR1_comp <- function(q_c_seed, minprior_value = 0.1, tag = "FMR1"){
  set.seed(q_c_seed)
  pi_init <- rep(1/K_up, K_up)
  rho_init <- rep(1, K_up)/sigma_est
  q_c_matrix <- abs(t(kronecker(pi_init, matrix(1, ncol = n))) + rnorm(n*K_up, mean = 0, sd = .1))
  q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  
  m_glm <- tryCatch({
    flexmix(y~cbind(X, Z)-1, cluster = q_c_matrix,
            model = FLXMRglm(),
            control = list(minprior = minprior_value))
  }, error = function(err) {
    cat("Error occurred:", conditionMessage(err), "\n")
    flexmix(y~cbind(X, Z)-1, k = K_up,
            model = FLXMRglm(),
            control = list(minprior = minprior_value))
  })
  
  est_sub_grn <- m_glm@k
  ci_est_sub <- m_glm@cluster
  coef_est <- parameters(m_glm)
  # rownames(coef_full_est) <- NULL
  ci_matrix <- matrix(0, nrow = n, ncol = est_sub_grn)
  ci_matrix[cbind(1:n, m_glm@cluster)] <- 1
  
  sc_score_main <- NaN
  ari_score_main <- NaN
  est_main_grn <- NaN
  est_sub_grn <- max(ci_est_sub)
  sc_score_sub <- sc(m_glm@cluster, ci_sim_sub)
  ari_score_sub <- ari(m_glm@cluster, ci_sim_sub)
  cdist <- tryCatch({ coef_dist(coef_est, coef$coef_full) }, error = function(err) {NaN})
  cdist_main <- tryCatch({ coef_dist(coef_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
  cdist_sub <- tryCatch({ coef_dist(coef_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
  
  pi_est = paste0("(", paste(as.character(round(prop.table(table(m_glm@cluster)),3)), collapse = ","), ")")
  
  y_hat <- rowSums(ci_matrix * data.frame(predict(m_glm)))
  mse <- sum((y-y_hat)^2/n)
  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = sc_score_sub,
              ari_score_main = ari_score_main,
              ari_score_sub = ari_score_sub,
              est_main_grn = est_main_grn,
              est_sub_grn = est_sub_grn,
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub)),4)), collapse = ","), ")"),
              mse = mse))
}
```

```{r}
# 这部分诊断为什么 compare 中计算的结果和直接在实验中计算的结果有差异
# q_c_seed <- 1
# comp <- FMR1_comp(q_c_seed)
# comresult <- NULL
# rbind(comresult, data.frame(comp))
# ori <- flexmix_init(q_c_seed, 0.1)
# ori
```

## FMR2

两次使用 FMR 方法得到层次模型模拟结果

```{r}
FMR2_comp <- function(q_c_seed, minprior_value = 0.1, tag = "FMR2"){
  set.seed(q_c_seed)
  pi_init <- rep(1/K_up, K_up)
  rho_init <- rep(1, K_up)/sigma_est
  q_c_matrix <- abs(t(kronecker(pi_init, matrix(1, ncol = n))) + rnorm(n*K_up, mean = 0, sd = .1))
  q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  
  # =========================== step 1 ===========================
  m_glm <- tryCatch({
    flexmix(y~cbind(X, Z)-1, cluster = q_c_matrix,
            model = FLXMRglm(),
            control = list(minprior = minprior_value))
  }, error = function(err) {
    cat("Error occurred:", conditionMessage(err), "\n")
    flexmix(y~cbind(X, Z)-1, k = K_up,
            model = FLXMRglm(),
            control = list(minprior = minprior_value))
  })
  est_main_grn <- m_glm@k
  ci_est_main <- m_glm@cluster
  coef_beta_est <- parameters(m_glm)[1:p,]
  rownames(coef_beta_est) <- NULL
  ci_matrix <- matrix(0, nrow = n, ncol = est_main_grn)
  ci_matrix[cbind(1:n, m_glm@cluster)] <- 1
  y_left <- y - rowSums(X %*% coef_beta_est * ci_matrix)
  
  # =========================== step 2 ===========================
  K_up2 <- K_up-est_main_grn+1
  coef_full_est <- NULL
  ci_est_sub <- rep(0, n)
  for(k_main in 1:est_main_grn){
    idx_k_main <- which(m_glm@cluster == k_main)
    y_left_k_main <- matrix(y_left[idx_k_main], ncol = 1)
    Z_k_main <- Z[idx_k_main,]
    pi_init <- rep(1/K_up2, K_up2)
    n2 <- length(idx_k_main)
    q_c_matrix <- abs(t(kronecker(pi_init, matrix(1, ncol = n2))) + rnorm(n2*K_up2, mean = 0, sd = .1))
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    m_glm_sub <- tryCatch({
      flexmix(y_left_k_main ~ Z_k_main-1, cluster = q_c_matrix,
              model = FLXMRglm(),
              control = list(minprior = minprior_value))
    }, error = function(err) {
      cat("Error occurred:", conditionMessage(err), "\n")
      flexmix(y_left_k_main ~ Z_k_main-1, k = K_up2,
              model = FLXMRglm(),
              control = list(minprior = minprior_value))
    })
    # est_sub_grn_k_main <- max(m_glm_sub@cluster)
    est_sub_grn_k_main <- m_glm_sub@k
    # K_up2 <- K_up2 - est_sub_grn_k_main + 1
    coef_alpha_est_k_main <- parameters(m_glm_sub)[1:q,]
    
    # if(k_main == 1){
    #   return(1)
    # }
    coef_full_est <- cbind(coef_full_est,
                           rbind(matrix(rep(matrix(coef_beta_est, nrow=p)[,k_main],
                                            est_sub_grn_k_main), 
                                        ncol = est_sub_grn_k_main),
                                 matrix(coef_alpha_est_k_main, 
                                        ncol = est_sub_grn_k_main)))
    ci_est_sub[idx_k_main] <- m_glm_sub@cluster + max(ci_est_sub)
  }
  # est_sub_grn <- max(ci_est_sub)
  est_sub_grn <- dim(coef_full_est)[2]
  # cdist
  cdist_main <- tryCatch({ coef_dist(coef_full_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
  if(is.na(cdist_main)){
    cdist_main <- tryCatch({ coef_dist(coef_beta_est, coef$coef_beta[, !duplicated(t(coef$coef_beta))]) }, error = function(err) {NaN})
  }
  cdist_sub <- tryCatch({ coef_dist(coef_full_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
  # sc
  sc_score_main <- sc(ci_est_main, ci_sim_main)
  sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
  # ari
  ari_score_main <- ari(ci_est_main, ci_sim_main)
  ari_score_sub <- ari(ci_est_sub, ci_sim_sub)
  # mse(in case)
  ci_matrix <- matrix(0, nrow = n, ncol = est_sub_grn)
  ci_matrix[cbind(1:n, ci_est_sub)] <- 1
  y_hat <- rowSums(ci_matrix * (cbind(X,Z) %*% coef_full_est))
  mse <- sum((y-y_hat)^2/n)
  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = sc_score_sub,
              ari_score_main = ari_score_main,
              ari_score_sub = ari_score_sub,
              est_main_grn = est_main_grn,
              est_sub_grn = est_sub_grn,
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub)),4)), collapse = ","), ")"),
              mse = mse))
}
```

## respclust1

```{r}
respclust1_comp <- function(q_c_seed, tag = "respclust1"){
  set.seed(q_c_seed)
  respclust <- kmeans(y, K_up)
  coef_full_est <- NULL
  for(k in 1:K_up){
    X_k <- X[which(respclust$cluster == k),]
    Z_k <- Z[which(respclust$cluster == k),]
    y_k <- y[which(respclust$cluster == k)]
    lm_k <- ncvfit(cbind(X_k,Z_k), y_k, lambda = 0.3, penalty = "MCP")
    coef_full_est <- cbind(coef_full_est, matrix(lm_k$beta))
  }
  sc_score_main <- NaN
  ari_score_main <- NaN
  est_main_grn <- NaN
  est_sub_grn <- K_up
  ci_est_sub <- respclust$cluster
  cdist_main <- tryCatch({ coef_dist(coef_full_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
  cdist_sub <- tryCatch({ coef_dist(coef_full_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
  sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
  ari_score_sub <- ari(ci_est_sub, ci_sim_sub)
  ci_matrix <- matrix(0, nrow = n, ncol = est_sub_grn)
  ci_matrix[cbind(1:n, ci_est_sub)] <- 1
  y_hat <- rowSums(cbind(X,Z) %*% coef_full_est * ci_matrix)
  mse <- sum((y-y_hat)^2/n)

  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = sc_score_sub,
              ari_score_main = ari_score_main,
              ari_score_sub = ari_score_sub,
              est_main_grn = est_main_grn,
              est_sub_grn = est_sub_grn,
              pi_est = paste0("(", paste(as.character(round(prop.table(respclust$size),4)), collapse = ","), ")"),
              mse = mse))
}
```


## respclust2

尝试使用 gap 统计量，但几乎全部认为是一类，暂时放弃，但是后续可能会用到

```{r}
# gap_stat <- clusGap(y, FUN = kmeans, nstart = 25, K.max = K_up, B = 20,)
# K_up1 <- maxSE(gap_stat$Tab[,"gap"], gap_stat$Tab[,"SE.sim"], method = "firstSEmax") + 1
```


```{r}
# 与 q_c_seed 无关，进行一次实验即可
respclust2_comp <- function(q_c_seed, tag = "respclust2"){
  set.seed(q_c_seed)
  K_up1_list <- c(2,3)
  K_up2_list <- c(1,2,3)
  K_pair_set <- expand.grid(list(K_up1 = K_up1_list, K_up2 = K_up2_list))
  df_K_set <- NULL
  coef_full_list <- NULL
  ci_est_main_list <- NULL
  ci_est_sub_list <- NULL
  for(test_idx in 1:nrow(K_pair_set)){
    K_up1 <- K_pair_set[test_idx,'K_up1']
    K_up2 <- K_pair_set[test_idx,'K_up2']
    
    coef_full_est <- NULL
    respclust <- kmeans(y, K_up1)
    ci_est_main <- respclust$cluster
    ci_est_sub <- rep(0, n)
    for(k in 1:K_up1){
      X_k <- X[which(respclust$cluster == k),]
      Z_k <- Z[which(respclust$cluster == k),]
      y_k <- y[which(respclust$cluster == k)]
      lm_k <- ncvfit(cbind(X_k,Z_k), y_k, lambda = 0.3, penalty = "MCP")
      coef_beta_est <- matrix(lm_k$beta[1:p])
      respclust2 <- kmeans(y_k, K_up2)
      ci_est_sub[which(ci_est_main == k)] <- respclust2$cluster + max(ci_est_sub)
      
      # 计算 step 2 的y值
      y_left_k <- y_k - (X_k %*% coef_beta_est)
      for(k2 in 1:K_up2){
        lm_k2 <- ncvfit(Z_k, y_left_k, lambda = 0.3, penalty = "MCP")
        coef_alpha_est <- matrix(lm_k2$beta)
        coef_full_est <- cbind(coef_full_est, c(coef_beta_est, coef_alpha_est))
      }
    }
    ci_est_main_list[[test_idx]] <- ci_est_main
    ci_est_sub_list[[test_idx]] <- ci_est_sub
    coef_full_list[[test_idx]] <- coef_full_est
    
    sc_score_main <- sc(ci_est_main, ci_sim_main)
    sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
    ari_score_main <- ari(ci_est_main, ci_sim_main) 
    ari_score_sub <- ari(ci_est_sub, ci_sim_sub) 
    cdist_main <- tryCatch({ coef_dist(coef_full_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
    cdist_sub <- tryCatch({ coef_dist(coef_full_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
    df_K_set <- rbind(df_K_set, c(cdist_main, cdist_sub, sc_score_main, sc_score_sub, ari_score_main, ari_score_sub))
  }
  df_K_set <- data.frame(df_K_set)
  colnames(df_K_set) <- c("cdist_main", "cdist_sub", "sc_score_main", "sc_score_sub", "ari_score_main", "ari_score_sub")
  idx_chosen <- which.max(rowMeans(df_K_set[,5:6], na.rm = TRUE))
  
  ci_est_main <- ci_est_main_list[[idx_chosen]]
  ci_est_sub <- ci_est_sub_list[[idx_chosen]]
  ci_matrix <- matrix(0, nrow = n, ncol = max(ci_est_sub_list[[idx_chosen]]))
  ci_matrix[cbind(1:n, ci_est_sub_list[[idx_chosen]])] <- 1
  y_hat <- rowSums(cbind(X,Z) %*% coef_full_list[[idx_chosen]] * ci_matrix)
  mse <- sum((y-y_hat)^2/n)
  
  cdist_main <- ifelse(is.na(df_K_set$cdist_main[idx_chosen]), 
                           mean(df_K_set$cdist_main, na.rm = TRUE),
                           df_K_set$cdist_main[idx_chosen])
  cdist_sub <- ifelse(is.na(df_K_set$cdist_sub[idx_chosen]), 
                           mean(df_K_set$cdist_sub, na.rm = TRUE),
                           df_K_set$cdist_sub[idx_chosen])
  sc_score_main <- ifelse(is.na(df_K_set$sc_score_main[idx_chosen]), 
                           mean(df_K_set$sc_score_main, na.rm = TRUE),
                           df_K_set$sc_score_main[idx_chosen])
  ari_score_main <- ifelse(is.na(df_K_set$ari_score_main[idx_chosen]), 
                           mean(df_K_set$ari_score_main, na.rm = TRUE),
                           df_K_set$ari_score_main[idx_chosen])
  
  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = df_K_set$sc_score_sub[idx_chosen],
              ari_score_main = ari_score_main,
              ari_score_sub = df_K_set$ari_score_sub[idx_chosen],
              est_main_grn = max(ci_est_main),
              est_sub_grn = max(ci_est_sub),
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub_list[[idx_chosen]])),4)), collapse = ","), ")"),
              mse = mse))
}
```


## resiclust1

```{r}
resiclust1_comp <- function(q_c_seed, tag = "resiclust1"){
  set.seed(q_c_seed)
  # 同质性假定下先计算系数，为了使用残差估计类别
  lm <- ncvfit(cbind(X,Z), y, lambda = 0.3, penalty = "MCP")
  resi <- y - cbind(X,Z)%*%lm$beta
  resiclust <- kmeans(resi, K_up)
  ci_est_main <- NaN
  ci_est_sub <- resiclust$cluster
  sc_score_main <- NaN
  sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
  ari_score_main <- NaN
  ari_score_sub <- ari(ci_est_sub, ci_sim_sub)
  est_main_grn <- NaN
  est_sub_grn <- K_up
  
  coef_full_est <- NULL
  for(k_main in 1:K_up){
    X_k <- X[which(resiclust$cluster == k_main),]
    Z_k <- Z[which(resiclust$cluster == k_main),]
    y_k <- y[which(resiclust$cluster == k_main)]
    lm_k <- ncvfit(cbind(X_k,Z_k), y_k, lambda = 0.3, penalty = "MCP")
    coef_full_est <- cbind(coef_full_est, matrix(lm_k$beta))
  }
  
  cdist_main <- tryCatch({ coef_dist(coef_full_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
  cdist_sub <- tryCatch({ coef_dist(coef_full_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
  
  ci_matrix <- matrix(0, nrow = n, ncol = est_sub_grn)
  ci_matrix[cbind(1:n, ci_est_sub)] <- 1
  y_hat <- rowSums(cbind(X,Z) %*% coef_full_est * ci_matrix)
  mse <- sum((y-y_hat)^2/n)

  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = sc_score_sub,
              ari_score_main = ari_score_main,
              ari_score_sub = ari_score_sub,
              est_main_grn = est_main_grn,
              est_sub_grn = est_sub_grn,
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub)),4)), collapse = ","), ")"),
              mse = mse))
}
```


## resiclust2


```{r}
resiclust2_comp <- function(q_c_seed, tag = "resiclust2"){
  set.seed(q_c_seed)
  # 同质性假定下先计算系数，为了使用残差估计类别
  K_up1_list <- c(2,3)
  K_up2_list <- c(1,2,3)
  K_pair_set <- expand.grid(list(K_up1 = K_up1_list, K_up2 = K_up2_list))
  
  lm <- ncvfit(cbind(X,Z), y, lambda = 0.3, penalty = "MCP")
  resi <- y - cbind(X,Z)%*%lm$beta
  
  ci_est_main_list <- NULL
  ci_est_sub_list <- NULL
  coef_full_list <- NULL
  df_K_set <- NULL
  for(test_idx in 1:nrow(K_pair_set)){
    coef_full_est <- NULL
    K_up1 <- K_pair_set[test_idx,'K_up1']
    K_up2 <- K_pair_set[test_idx,'K_up2']
    resiclust <- kmeans(resi, K_up1)
    # 大类分类结果
    ci_est_main <- resiclust$cluster
    ci_est_main_list[[test_idx]] <- resiclust$cluster
    
    ci_est_sub <- rep(0, n)
    for(k_main in 1:K_up1){
      # 在各个大组内先估计系数 beta
      X_k <- X[which(resiclust$cluster == k_main),]
      Z_k <- Z[which(resiclust$cluster == k_main),]
      y_k <- y[which(resiclust$cluster == k_main)]
      lm_k <- ncvfit(cbind(X_k,Z_k), y_k, lambda = 0.3, penalty = "MCP")
      coef_beta_est <- lm_k$beta[1:p]
      # 计算大组内残差（使用全 XZ 而非只有 X），方便小组聚类
      resi_k <- y_k - cbind(X_k,Z_k)%*%lm_k$beta
      y_left_k <- y_k - X_k%*%coef_beta_est # 大组内新的 response variable 方便 alpha 估计
      # 小组分类结果
      resiclust2 <- kmeans(resi_k, K_up2)
      ci_est_sub[which(ci_est_main == k_main)] <- resiclust2$cluster + max(ci_est_sub)
      for(k_sub in 1:K_up2){
        # 在各个小组内估计系数 alpha
        X_k2 <- X_k[which(resiclust2$cluster == k_sub),]
        Z_k2 <- Z_k[which(resiclust2$cluster == k_sub),]
        y_k2 <- y_left_k[which(resiclust2$cluster == k_sub)] 
        lm_k2 <- ncvfit(Z_k2, y_k2, lambda = 0.3, penalty = "MCP")
        coef_full_est <- cbind(coef_full_est, c(coef_beta_est, lm_k2$beta))
      }
    }
    ci_est_main_list[[test_idx]] <- ci_est_main
    ci_est_sub_list[[test_idx]] <- ci_est_sub
    coef_full_list[[test_idx]] <- coef_full_est
    
    sc_score_main <- sc(ci_est_main, ci_sim_main)
    sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
    ari_score_main <- ari(ci_est_main, ci_sim_main)
    ari_score_sub <- ari(ci_est_sub, ci_sim_sub)
    cdist_main <- tryCatch({ coef_dist(coef_full_est[1:p,], coef$coef_beta) }, error = function(err) {NaN})
    cdist_sub <- tryCatch({ coef_dist(coef_full_est[(p+1):(p+q),], coef$coef_alpha) }, error = function(err) {NaN})
    df_K_set <- rbind(df_K_set, c(cdist_main, cdist_sub, sc_score_main, sc_score_sub, ari_score_main, ari_score_sub))
  }
  
  df_K_set <- data.frame(df_K_set)
  colnames(df_K_set) <- c("cdist_main", "cdist_sub", "sc_score_main", "sc_score_sub", "ari_score_main", "ari_score_sub")
  idx_chosen <- which.max(rowMeans(df_K_set[,c(4,6)]))
  # idx_chosen <- which.max(df_K_set[,4])
  
  ci_matrix <- matrix(0, nrow = n, ncol = max(ci_est_sub_list[[idx_chosen]]))
  ci_matrix[cbind(1:n, ci_est_sub_list[[idx_chosen]])] <- 1
  y_hat <- rowSums(cbind(X,Z) %*% coef_full_list[[idx_chosen]] * ci_matrix)
  mse <- sum((y-y_hat)^2/n)
  
  ci_est_main <- ci_est_main_list[[idx_chosen]]
  ci_est_sub <- ci_est_sub_list[[idx_chosen]]
  
  cdist_main <- ifelse(is.na(df_K_set$cdist_main[idx_chosen]), 
                           mean(df_K_set$cdist_main, na.rm = TRUE),
                           df_K_set$cdist_main[idx_chosen])
  cdist_sub <- ifelse(is.na(df_K_set$cdist_sub[idx_chosen]), 
                           mean(df_K_set$cdist_sub, na.rm = TRUE),
                           df_K_set$cdist_sub[idx_chosen])
  sc_score_main <- ifelse(is.na(df_K_set$sc_score_main[idx_chosen]), 
                           mean(df_K_set$sc_score_main, na.rm = TRUE),
                           df_K_set$sc_score_main[idx_chosen])
  ari_score_main <- ifelse(is.na(df_K_set$ari_score_main[idx_chosen]), 
                           mean(df_K_set$ari_score_main, na.rm = TRUE),
                           df_K_set$ari_score_main[idx_chosen])
  
  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              # coef_full_ori = coef_full_est,
              sc_score_main = sc_score_main,
              sc_score_sub = df_K_set$sc_score_sub[idx_chosen],
              ari_score_main = ari_score_main,
              ari_score_sub = df_K_set$ari_score_sub[idx_chosen],
              est_main_grn = max(ci_est_main),
              est_sub_grn = max(ci_est_sub),
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub)),4)), collapse = ","), ")"),
              mse = mse))
}
```

## oracle

和其他方法差别比较大，基本全部使用 proposed 的框架，但要修改 q_c_matrix 为已知，且不更新 q_c_matrix 以及 pi，为了方便直接用原有 func.R 中的函数做修改

```{r}
# 实际用不到 q_c_seed
# 注意 oracle 不存在组别压缩的问题，不同 K_up 对应的估计结果相同
oracle_comp <- function(q_c_seed, iter_type = 'stop', iter_max = 200, 
                       rho_ratio = 0, sigma_est = 0.5, K_up_true = 4, 
                        rho_clip = 4, plot_performance = FALSE,
                        eps = 1e-7, eps_abs = 1e-2, eps_rel = 1e-3, tag = "oracle"){
  # iter_type = 'stop'
  # iter_max = 200
  # rho_ratio = 0
  # sigma_est = 0.5
  # K_up_true = 4
  # rho_clip = 4
  # plot_performance = FALSE
  # eps = 1e-7
  # eps_abs = 1e-2
  # eps_rel = 1e-3
  # tag = "oracle"
  tau <- ifelse(tau == 0, 1e-4, tau) # 防止 tau == 0 导致分母为0情况
  sigma_est = ifelse(sigma_est == 0, 0.01, sigma_est)
  rho_init <- rep(1, K_up)/sigma_est
  
  kj <- function(dim) {return((k-1)*dim+j)}
  ks <- function(dim) {return((k-1)*dim+s)}
  rho_list <- list(rho_init)
  pi_init <- rep(1/K_up, K_up)
  pi_list <- list(pi_init)
  set.seed(q_c_seed)
  q_c_matrix <- get_q_c_matrix(n, K_up, ci_sim)
  q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  
  coef_full_init <- matrix(0, nrow = p+q, ncol = K_up)
  coef_full_list <- list(coef_full_init*t(kronecker(rho_init, matrix(1, ncol = p+q))))
  coef_full_ori_list <- list(coef_full_init)
  
  # coef diff (v,w):=u
  diff_v_init <- matrix(H_p %*% as.vector(coef_full_init[1:p,]), ncol = 1)
  # diff_v_init <- matrix(H_p %*% as.vector(coef$coef_beta), ncol = 1)
  diff_v_list <- list(diff_v_init)
  diff_w_init <- matrix(H_q %*% as.vector(coef_full_init[(p+1):(p+q),]), ncol = 1)
  # diff_w_init <- matrix(H_q %*% as.vector(coef$coef_alpha), ncol = 1)
  diff_w_list <- list(diff_w_init)
  
  # dual variable (xi,zeta):=eta
  dual_xi_init <- matrix(0, nrow = (p)*K_up*(K_up-1)/2, ncol = 1)
  dual_xi_list <- list(dual_xi_init)
  dual_zeta_init <- matrix(0, nrow = (q)*K_up*(K_up-1)/2, ncol = 1)
  dual_zeta_list <- list(dual_zeta_init)
  
  resi_dual_list <- list(NULL)
  resi_prim_list <- list(NULL)
  eps_dual_list <- list(NULL)
  eps_prim_list <- list(NULL)
  
  case <- NULL
  cu_tracker <- NULL
  cv_tracker <- NULL
  for(iter in 2:iter_max){
    rho_est <- rho_list[[iter-1]]
    coef_full_est <- coef_full_list[[iter-1]]
    coef_beta_est <- coef_full_est[1:p,]
    coef_alpha_est <- coef_full_est[(p+1):(p+q),]
    
    diff_v_est <- diff_v_list[[iter-1]]
    diff_w_est <- diff_w_list[[iter-1]]
    
    dual_xi_est <- dual_xi_list[[iter-1]]
    dual_zeta_est <- dual_zeta_list[[iter-1]]
    
    # rho_k 的更新
    # update_step = ifelse(iter > 10, 0.4, 0)
    rho_ratio = 0
    for(k in 1:K_up){
      W_k <- diag(q_c_matrix[,k])
      onen <- matrix(1, nrow = n, ncol = 1)
      AA <- as.numeric(t(y) %*% W_k %*% y)
      BB <- as.numeric(-t(y) %*% W_k %*% (X%*%coef_beta_est[,k] + Z%*%coef_alpha_est[,k]))
      CC <- as.numeric(-t(onen) %*% W_k %*% onen)
      rho_k_est <- (-BB+sqrt(BB**2-4*AA*CC))/(2*AA)
      rho_k_est <- ifelse(rho_k_est <= 0.5, 1, min(rho_clip, rho_k_est))
      rho_est[k] <- rho_ratio*rho_k_est + (1-rho_ratio)*rho_est[k]
    }
    
    rho_list[[iter]] <- rho_est
    
    # =========================== beta, alpha update =========================
    # beta,alpha （相比矩阵形式，只修改 beta,alpha 更新）
    for(k in 1:K_up){
      W_k <- diag(q_c_matrix[,k])
      for(j in 1:p){
        lower_1 <- t(X[,j]) %*% W_k %*% X[,j]
        lower_2 <- (t(H_p)%*%H_p)[kj(p), kj(p)]
        # lower_2 <- 0
        Lower <- lower_1/n + tau*lower_2
        upper_1 <- t(X[,j]) %*% W_k %*% (rho_est[k]*y - X[,-j]%*%(coef_beta_est[-j,k]) - Z%*%coef_alpha_est[,k])
        upper_2 <- (t(H_p)%*%(diff_v_est-dual_xi_est))[kj(p)] - 
          as.vector(coef_beta_est)[-kj(p)]%*%((t(H_p)%*%H_p)[kj(p),-kj(p)])
        # upper_2 <- 0
        Upper <- upper_1/n + tau*upper_2
        # coef_beta_kj <- Upper/Lower
        coef_beta_kj <- mcp_solution(Lower, Upper/Lower, aa, lambda_1)
        coef_beta_est[j,k] <- coef_beta_kj
      }
      for(s in 1:q){
        lower_1 <- t(Z[,s]) %*% W_k %*% Z[,s]
        lower_2 <- (t(H_q)%*%H_q)[ks(q), ks(q)]
        # lower_2 <- 0
        Lower <- lower_1/n + tau*lower_2
        upper_1 <- t(rho_est[k]*y - Z[,-s]%*%(coef_alpha_est[-s,k]) - X%*%coef_beta_est[,k]) %*% W_k %*% Z[,s]
        upper_2 <- (t(H_q)%*%(diff_w_est-dual_zeta_est))[ks(q)] - 
          as.vector(coef_alpha_est)[-ks(q)]%*%((t(H_q)%*%H_q)[ks(q),-ks(q)])
        # upper_2 <- 0
        Upper <- upper_1/n + tau*upper_2
        # coef_alpha_ks <- Upper/Lower
        coef_alpha_ks <- mcp_solution(Lower, Upper/Lower, aa, lambda_1)
        coef_alpha_est[s,k] <- coef_alpha_ks
      }
    }
    coef_full_est <- rbind(coef_beta_est, coef_alpha_est)
    coef_full_list[[iter]] <- coef_full_est
    coef_full_ori_list[[iter]] <- coef_full_est/extend_x_to_row(rho_est,p+q)
    
    diff_v_est <- matrix(H_p %*% as.vector(coef_beta_est), ncol = 1)
    diff_w_est <- matrix(H_q %*% as.vector(coef_alpha_est), ncol = 1)
    diff_v_last <- diff_v_list[[iter-1]]
    diff_w_last <- diff_w_list[[iter-1]]
    
    # v,w 的更新 2 means prime
    diff_v2_est <- H_p%*%as.vector(coef_beta_est) + dual_xi_est
    diff_w2_est <- H_q%*%as.vector(coef_alpha_est) + dual_zeta_est
    
    for(k1 in 1:(K_up-1)){
      for(k2 in (k1+1):K_up){
        ikk <- which(apply(comb_pair, 2, function(x){all(x==c(k1,k2))}))
        
        v_kk <- diff_v_est[((ikk-1)*p+1):(ikk*p)]
        w_kk <- diff_w_est[((ikk-1)*q+1):(ikk*q)]
        u_kk <- c(v_kk, w_kk)
        
        v_kk_last <- diff_v_last[((ikk-1)*p+1):(ikk*p)]
        w_kk_last <- diff_w_last[((ikk-1)*q+1):(ikk*q)]
        u_kk_last <- c(v_kk_last, w_kk_last)
        
        v_kk.F <- norm(matrix(v_kk_last), type = "2")
        w_kk.F <- norm(matrix(w_kk_last), type = "2")
        u_kk.F <- sqrt(v_kk.F**2 + w_kk.F**2)
        
        v_kk2 <- diff_v2_est[((ikk-1)*p+1):(ikk*p)]
        w_kk2 <- diff_w2_est[((ikk-1)*q+1):(ikk*q)]
        
        v_kk2.F <- norm(matrix(v_kk2), type = "2")
        w_kk2.F <- norm(matrix(w_kk2), type = "2")
        u_kk2.F <- sqrt(v_kk2.F**2 + w_kk2.F**2)
        
        cu <- positive_part(1-lambda_2/tau/u_kk2.F)/(1-1/aa/tau)
        cv <- positive_part(1-lambda_3/tau/v_kk2.F)/(1-1/aa/tau)
        if(is.na(cu)){ print(paste(iter, "cu na of k1 k2", k1, k2)); cu <- 0 }
        if(is.na(cv)){ print(paste(iter, "cv na of k1 k2", k1, k2)); cv <- 0 }
        # 判断压缩类别
        case_kk <- case_when(
          (u_kk2.F > aa*lambda_2) & (v_kk2.F > aa*lambda_3) ~ 1,
          (u_kk2.F <= aa*lambda_2) & (cu*v_kk2.F > aa*lambda_3) ~ 2,
          (w_kk2.F**2+(cv*v_kk2.F)**2 > (aa*lambda_2)**2) &
            (v_kk2.F <= aa*lambda_3) ~ 3,
          TRUE ~ 4
        )
        # tracker
        case <- c(case, case_kk)
        cu_tracker <- c(cu_tracker, cu)
        cv_tracker <- c(cv_tracker, cv)
        
        if(case_kk == 1){
          diff_v_est[((ikk-1)*p+1):(ikk*p)] <- v_kk2
          diff_w_est[((ikk-1)*q+1):(ikk*q)] <- w_kk2
        }else if(case_kk == 2){
          diff_v_est[((ikk-1)*p+1):(ikk*p)] <- cu*v_kk2
          diff_w_est[((ikk-1)*q+1):(ikk*q)] <- cu*w_kk2
        }else if(case_kk == 3){
          diff_v_est[((ikk-1)*p+1):(ikk*p)] <- cv*v_kk2
          diff_w_est[((ikk-1)*q+1):(ikk*q)] <- w_kk2
        }else{
          diff_v_est[((ikk-1)*p+1):(ikk*p)] <- v_kk2/
            (1+mcp_d(u_kk.F,aa,lambda_2,TRUE)/tau/(u_kk.F+eps) +
               mcp_d(v_kk.F,aa,lambda_3,TRUE)/tau/(v_kk.F+eps))
          diff_w_est[((ikk-1)*q+1):(ikk*q)] <- w_kk2/
            (1+mcp_d(u_kk.F,aa,lambda_2,TRUE)/tau/(u_kk.F+eps))
        }
      }
    }
    diff_v_list[[iter]] <- diff_v_est
    diff_w_list[[iter]] <- diff_w_est
    
    # xi,zeta 的更新
    dual_xi_list[[iter]] <- dual_xi_list[[iter-1]] +
      (matrix(H_p%*%as.vector(coef_beta_est),ncol=1) - diff_v_list[[iter]])
    dual_zeta_list[[iter]] <- dual_zeta_list[[iter-1]] +
      (matrix(H_q%*%as.vector(coef_alpha_est),ncol=1) - diff_w_list[[iter]])
    
    # stopping criteria
    if(iter_type == "stop"){
      resi_prim <- rbind(matrix(H_p%*%as.vector(coef_beta_est),ncol=1) - diff_v_list[[iter]],
                         matrix(H_q%*%as.vector(coef_alpha_est),ncol=1) - diff_w_list[[iter]]) %>%
        norm(type = '2')
      resi_dual <- rbind(-tau * t(H_p) %*% (diff_v_list[[iter]] - diff_v_list[[iter-1]]),
                         -tau * t(H_q) %*% (diff_w_list[[iter]] - diff_w_list[[iter-1]])) %>%
        norm(type = '2')
      resi_prim_list[[iter]] <- resi_prim
      resi_dual_list[[iter]] <- resi_dual
      
      eps_prim <- sqrt(K_up*(K_up-1)/2*(p+q))*eps_abs + 
        eps_rel*max(norm(rbind(H_p%*%as.numeric(coef_beta_est), H_q%*%as.numeric(coef_alpha_est)), type = '2'), 
                    norm(rbind(diff_v_est, diff_w_est), type = '2'))
      eps_dual <- sqrt(K_up*(p+q))*eps_abs +
        eps_rel*norm(rbind(t(H_p)%*%dual_xi_list[[iter]], t(H_q)%*%dual_zeta_list[[iter]]), type = '2')
      eps_prim_list[[iter]] <- eps_prim
      eps_dual_list[[iter]] <- eps_dual
      
      if((resi_prim < eps_prim) & (resi_dual < eps_dual)){
        break
      }
    }
    
    # update q_c matrix
    pi_est <- apply(q_c_matrix, 2, sum)/n
    pi_list[[iter]] <- pi_est
  }
  # ========================= 计算结束整理结果 ==============================
  cdist <- tryCatch({
    coef_dist(coef_full_ori_list[[iter]], coef$coef_full)
  }, error = function(err) {NaN})
  
  # case 情况（检查是否落入组别压缩的情况
  case_table_full <- rep(0, 4) # v,w 更新四种情况落入次数记录
  case_table <- table(case)
  for(t in 1:dim(case_table)){
    case_table_full[as.integer(names(case_table)[t])] <- case_table[names(case_table)[t]]
  }
  
  # 参数距离可视化 & 停止准则和对应临界值
  if(plot_performance){
    plot(1:iter, c(resi_prim_list[[2]], unlist(resi_prim_list)), col = "Black", main = "primary")
    points(c(eps_prim_list[[2]], unlist(eps_prim_list)), col = "DeepPink")
    lines(c(resi_prim_list[[2]], unlist(resi_prim_list)), col = "Black")
    lines(c(eps_prim_list[[2]], unlist(eps_prim_list)), col = "DeepPink")
    
    plot(1:iter, c(resi_dual_list[[2]], unlist(resi_dual_list)), col = "Black", main = "dual")
    points(c(eps_dual_list[[2]], unlist(eps_dual_list)), col = "DeepPink")
    lines(c(resi_dual_list[[2]], unlist(resi_dual_list)), col = "Black")
    lines(c(eps_dual_list[[2]], unlist(eps_dual_list)), col = "DeepPink")
    # 估计参数距离真实参数距离的可视化展示
    # 类别个数与真实不相同时，以下可视化会出错
    tryCatch(
      plot(unlist(lapply(coef_full_ori_list, coef_dist, coef$coef_full)), ylab = "",
           main = paste(q_c_seed, aa, lambda_1, lambda_2, lambda_3, tau))
      , error = function(e) e)
  }
  
  ci_est <- apply(q_c_matrix, 1, which.max)
  sc_score <- tryCatch({
    sc(ci_est, ci_sim)
  }, error = function(err) {NaN})
  ari_score <- tryCatch({
    ari(ci_est, ci_sim)
  }, error = function(err) {NaN})
  
  ci_prob <- apply(q_c_matrix, 1, max)
  ci_matrix <- t(apply(q_c_matrix, 1, function(x){as.numeric(x == max(x))}))
  y_hat <- rowSums(ci_matrix * data%*%coef_full_list[[iter]])
  mse <- sum((y-y_hat)^2/n)
  
  # group result
  main_group_info <- get_group_num(K_up, 
                                  coef_full_ori_list[[iter]][(1:p),], 
                                  diff_v_list[[iter]], p)
  sub_group_info <- get_group_num(K_up, 
                                  coef_full_ori_list[[iter]][(1+p):(p+q),], 
                                  diff_w_list[[iter]], q)

  # est_main_grn <- main_group_info$gr.num
  # est_sub_grn <- sub_group_info$gr.num
  
  cappfl.diff <- main_group_info$capgfl.matrix2 - sub_group_info$capgfl.matrix2
  valid_hier <- ifelse(min(cappfl.diff) >= 0, TRUE, FALSE)
  diag(cappfl.diff) <- 1
  
  # ==========================================================================
  # 压缩到相同类后，再计算 sc，ari d等指标得分
  # (1) 找到哪些类别为同一大组，小组
  main_group_info_compact <- find_connected_nodes(main_group_info$capgfl.matrix2)
  sub_group_info_compact <- find_connected_nodes(sub_group_info$capgfl.matrix2)
  est_main_grn <- length(main_group_info_compact)
  est_sub_grn <- length(sub_group_info_compact)
  
  # (2) 计算平均的系数，可以根据样本数进行加权，但因为数值非常接近，可以直接求平均
  coef_beta_ori_comp <- matrix(NaN, p, est_main_grn)
  coef_alpha_ori_comp <- matrix(NaN, q, est_sub_grn)
  coef_full_ori_comp <- matrix(NaN, p+q, est_sub_grn)
  for(k in 1:est_main_grn){
    # 多于两类才需要压缩，否则取原值
    if(length(main_group_info_compact[[k]]) > 1){
      coef_beta_ori_comp[,k] <- rowMeans(coef_full_ori_list[[iter]][1:p,][,main_group_info_compact[[k]]])
    }else{
      coef_beta_ori_comp[,k] <- coef_full_ori_list[[iter]][1:p,][,main_group_info_compact[[k]]]
    }
  }
  for(k in 1:est_sub_grn){
    # 多于两类才需要压缩，否则取原值
    if(length(sub_group_info_compact[[k]]) > 1){
      coef_alpha_ori_comp[,k] <- rowMeans(coef_full_ori_list[[iter]][(p+1):(p+q),][,sub_group_info_compact[[k]]])
    }else{
      coef_alpha_ori_comp[,k] <- coef_full_ori_list[[iter]][(p+1):(p+q),][,sub_group_info_compact[[k]]]
    }
  }
  for(k in 1:K_up){
    coef_full_ori_comp[,which(sapply(sub_group_info_compact, function(x) k %in% x))][(p+1):(p+q)] <- coef_alpha_ori_comp[,which(sapply(sub_group_info_compact, function(x) k %in% x))]
    coef_full_ori_comp[,which(sapply(sub_group_info_compact, function(x) k %in% x))][1:p] <- coef_beta_ori_comp[,which(sapply(main_group_info_compact, function(x) k %in% x))]
  }
  ci_est_main <- sapply(ci_est, function(k){which(sapply(main_group_info_compact, function(x) k %in% x))})
  ci_est_sub <- sapply(ci_est, function(k){which(sapply(sub_group_info_compact, function(x) k %in% x))})
  
  sc_score_main <- sc(ci_est_main, ci_sim_main)
  sc_score_sub <- sc(ci_est_sub, ci_sim_sub)
  ari_score_main <- ari(ci_est_main, ci_sim_main)
  ari_score_sub <- ari(ci_est_sub, ci_sim_sub)
  # per 无法再此处计算，汇总函数中再计算
  cdist_main <- tryCatch({ coef_dist(coef_full_ori_comp[1:p,], coef$coef_beta) }, error = function(err) {NaN})
  if(is.na(cdist_main)){
    cdist_main <- tryCatch({ coef_dist(coef_beta_ori_comp, coef$coef_beta[, !duplicated(t(coef$coef_beta))]) }, error = function(err) {NaN})
  }
  cdist_sub <- tryCatch({ coef_dist(coef_alpha_ori_comp, coef$coef_alpha) }, error = function(err) {NaN})
  # ==========================================================================
  
  group_detail <- paste0(convert_to_parentheses(main_group_info_compact), ";",
                        convert_to_parentheses(sub_group_info_compact))
  # print(coef_full_ori_list[[iter]])
  bic_info <- bic_score(q_c_matrix, coef_full_ori_list[[iter]], 
                        est_main_grn, est_sub_grn, rho_est)
  return(list(dt_seed = dt_seed,
              q_c_seed = q_c_seed,
              tag = tag,
              penal = bic_info$penal,
              bic_sum = bic_info$bic_sum,
              bic_mean = bic_info$bic_mean,
              cdist_main = cdist_main,
              cdist_sub = cdist_sub,
              sc_score_main = sc_score_main,
              sc_score_sub = sc_score_sub,
              ari_score_main = ari_score_main,
              ari_score_sub = ari_score_sub,
              est_main_grn = est_main_grn,
              est_sub_grn = est_sub_grn,
              pi_est = paste0("(", paste(as.character(round(prop.table(table(ci_est_sub)),4)), collapse = ","), ")"),
              mse = mse))
}
```


# 总实验

## 单 dt_seed

### 直接

分析 oracle.R 运行结果

```{r}
df <- read.csv("2024-03-09_n500_p80_q40_b1_ss1_bl3_al2_eps0.5_epi0.5_rr0_Kup4_ctEn_oracle.csv")
df_result <- df %>% 
  group_by(dt_seed) %>%
  arrange(bic_mean, .by_group=TRUE) %>%
  filter(row_number() == 1)
df_result2 <- df_result %>%
  # select(-dt_seed) %>%
  transmute(per_main = (est_main_grn == 2),
         per_sub = (est_sub_grn == 4),
         sc_main = sc_score_main,
         sc_sub = sc_score_sub,
         ari_main = ari_score_main,
         ari_sub = ari_score_sub,
         MSE_main = cdist_main,
         MSE_sub = cdist_sub)
as.data.frame(t(colMeans(df_result2, na.rm = T)))
```




### 计算

```{r}
# comresult <- NULL
# for(q_c_seed in 1:q_c_seed_max){
#   comresult <- rbind(comresult, data.frame(FMR1_comp(q_c_seed)))
#   comresult <- rbind(comresult, data.frame(FMR2_comp(q_c_seed)))
#   comresult <- rbind(comresult, data.frame(respclust1_comp(q_c_seed)))
#   comresult <- rbind(comresult, data.frame(respclust2_comp(q_c_seed)))
#   comresult <- rbind(comresult, data.frame(resiclust1_comp(q_c_seed)))
#   comresult <- rbind(comresult, data.frame(resiclust2_comp(q_c_seed)))
# }
```

```{r}
q_c_seed <- 1
iter_max <- 200
l2_seq <- c(0,0.5,1,1.2,1.5)
l3_seq <- c(0,0.5,1,1.2,1.5)
fix_para <- list(dt_seed = dt_seed, q_c_seed = q_c_seed, lambda_1 = 0.3,
                 aa = 1.2, tau = 1)
trail_set <- expand.grid(list(l3 = l3_seq, l2 = l2_seq))
oraresult <- NULL
trail_num <- nrow(trail_set)
for(trail_idx in 1:trail_num){
  aa <- fix_para$aa
  tau <- fix_para$tau
  lambda_1 <- fix_para$lambda_1
  lambda_2 <- trail_set$l2[trail_idx]
  lambda_3 <- trail_set$l3[trail_idx]
  
  trail <- oracle_comp(q_c_seed)
  oraresult <- rbind(oraresult, c(trail$dt_seed, trail$q_c_seed, lambda_2, lambda_3,
                                   trail$tag, trail$penal, trail$bic_sum, trail$bic_mean,
                                   trail$cdist_main, trail$cdist_sub,
                                   trail$sc_score_main, trail$sc_score_sub,
                                   trail$ari_score_main, trail$ari_score_sub,
                                   trail$est_main_grn, trail$est_sub_grn,
                                   trail$pi_est, trail$mse))
  
  
}
oraresult <- data.frame(oraresult)
colnames(oraresult) <- c("dt_seed", "q_c_seed", "lambda_2", "lambda_3", "tag", 
                         "penal", "bic_sum", "bic_mean", 
                         "cdist_main", "cdist_sub", "sc_score_main",
                         "sc_score_sub", "ari_score_main", "ari_score_sub",
                         "est_main_grn", "est_sub_grn", "pi_est", "mse")
oraresult$bic_mean <- as.numeric(oraresult$bic_mean)
```


```{r}
data.frame(t1)
data.frame(t2)
```

```{r}
ora_result <- oraresult %>% 
  arrange(bic_mean) %>%
  filter(row_number() == 1) %>%
  select(sc_main = sc_score_main,
         sc_sub = sc_score_sub,
         ari_main = ari_score_main,
         ari_sub = ari_score_sub,
         MSE_main = cdist_main,
         MSE_sub = cdist_sub)
ora_result
```

```{r}
# comresult %>% group_by(dt_seed) %>% 
#   summarise(tag = min(tag),
#             cdist_main = mean(cdist_main),
#             cdist_sub = mean(cdist_sub),
#             # coef_full_ori = coef_full_est,
#             sc_score_main = mean(sc_score_main),
#             sc_score_sub = mean(sc_score_sub),
#             ari_score_main = mean(ari_score_main),
#             ari_score_suub = mean(ari_score_suub),
#             est_main_grn = mean(est_main_grn),
#             est_sub_grn = mean(est_sub_grn),
#             mse = mean(mse))
```

## 全 dt_seed


```{r}
n <- 500
p <- 80
q <- 40
epsilon_sd <- 0.5
epsilon_sd_init <- 0.5
sigma_est <- as.numeric(epsilon_sd_init)
balance <- 2
signal_size <- 2
beta_vlen <- 3
alpha_vlen <- 2
save_path <- "temp.csv"
# dt_seed <- 9
K_up <- 6  # 估计时的最大类别，应该不少于 group_num_sub

cotype_x <- "En"
cotype_z <- "En"
beta_nonzero <- c(-2, -2, 2, 2)*signal_size # 长度应和真实 group_num_sub 保持一致
alpha_nonzero <- c(-3, -1, 1, 3)*signal_size

q_c_seed_max <- 10
group_num_main <- 2                    
group_num_sub <- 4    
hier_struc <- list(c(1,2),c(3,4))
# prob_sub <- rep(1/group_num_sub, group_num_sub)  
if(balance == 1){
  prob_sub <- rep(1/group_num_sub, group_num_sub)
}else if(balance == 2){
  prob_sub<-c(1/6,1/6,1/3,1/3)
}else{
  prob_sub<-c(1/6,1/3,1/6,1/3)
}
reverse <- FALSE

# =============================== prepare =================================
comb_pair <- combn(K_up, 2)
H_p <- kronecker(t(apply(comb_pair, 2, get_e_mat, K_up)),
                 diag(p)) %>% Matrix(sparse = TRUE)
H_q <- kronecker(t(apply(comb_pair, 2, get_e_mat, K_up)),
                 diag(q)) %>% Matrix(sparse = TRUE)


# =============================== result =================================
colnames_part <- c("dt_seed", "q_c_seed", "tag", "mse", 
                   "cdist_main", "cdist_sub", "ci_prob_mean",
                  "sc", "sc_main", "sc_sub","ari", "ari_main", "ari_sub",
                  "main_grn", "sub_grn", "pi_est","group_detail")
```


```{r}
comresult <- NULL
for(dt_seed in seq(9,99,10)){
  whole.data <- generate_all_data(dt_seed, n, p, q, prob_sub, hier_struc, 
                                beta_nonzero, alpha_nonzero, beta_vlen, alpha_vlen, 
                                cotype_x, cotype_z, epsilon_sd, reverse)
  X <- whole.data$data$X
  Z <- whole.data$data$Z
  data <- whole.data$data$data_full
  coef <- whole.data$coef
  # coefv <- lapply(coef, as.vector) # 按照类别拉长
  ci_sim <- whole.data$ci_sim
  ci_sim_main <- whole.data$ci_sim_main
  ci_sim_sub <- whole.data$ci_sim_sub
  y <- matrix(whole.data$y, ncol=1)
  
  for(q_c_seed in 1:q_c_seed_max){
    FMR1_res <- tryCatch({ data.frame(FMR1_comp(q_c_seed)) }, 
             error = function(err) { cat("Error occurred when:", dt_seed, 
                                         "q_c_seed:", q_c_seed, "\n") ; NULL})
    FMR2_res <- tryCatch({ data.frame(FMR2_comp(q_c_seed)) }, 
             error = function(err) { cat("Error occurred when:", dt_seed, 
                                         "q_c_seed:", q_c_seed, "\n") ; NULL})
    comresult <- rbind(comresult, FMR1_res)
    comresult <- rbind(comresult, FMR2_res)
    comresult <- rbind(comresult, data.frame(respclust1_comp(q_c_seed)))
    comresult <- rbind(comresult, data.frame(respclust2_comp(q_c_seed)))
    comresult <- rbind(comresult, data.frame(resiclust1_comp(q_c_seed)))
    comresult <- rbind(comresult, data.frame(resiclust2_comp(q_c_seed)))
  }
}
```

```{r}
df_report <- comresult %>% group_by(tag, dt_seed) %>%
  summarise(tag = min(tag),
            dt_seed = min(dt_seed),
            per_main = sum(est_main_grn == 2, na.rm = FALSE)/n(),
            per_sub = sum(est_sub_grn == 4, na.rm = FALSE)/n(),
            sc_main = mean(sc_score_main, na.rm = TRUE),
            sc_sub = mean(sc_score_sub, na.rm = TRUE),
            ari_main = mean(ari_score_main, na.rm = TRUE),
            ari_sub = mean(ari_score_sub, na.rm = TRUE),
            MSE_main = mean(cdist_main, na.rm = TRUE),
            MSE_sub = mean(cdist_sub, na.rm = TRUE), .groups = "drop")
df_report2 <- df_report %>% group_by(tag) %>%
  summarise(tag = min(tag),
            per_main = mean(per_main, na.rm = TRUE),
            per_sub = mean(per_sub, na.rm = TRUE),
            sc_main = mean(sc_main, na.rm = TRUE),
            sc_sub = mean(sc_sub, na.rm = TRUE),
            ari_main = mean(ari_main, na.rm = TRUE),
            ari_sub = mean(ari_sub, na.rm = TRUE),
            MSE_main = mean(MSE_main, na.rm = TRUE),
            MSE_sub = mean(MSE_sub, na.rm = TRUE), .groups = "drop")

df_result <- df_report2 %>% select(-tag)
write.table(format(df_result, nsmall = 4), "clipboard", sep = "\t", row.names = FALSE, col.names = FALSE)
```

```{r}
df_report2 %>% arrange(tag)
```




```{r}
df_tmp <- df_report %>% filter(tag == 'FMR2')
```





