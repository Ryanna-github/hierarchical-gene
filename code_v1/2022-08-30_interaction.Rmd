---
title: "interaction version"
author: "renyan"
date: "2022-08-30"
output: 
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r, echo = FALSE}
rm(list = ls(all = TRUE))
# setwd("D:/Ryanna/RUC_courses/Y1_2/Group/code")
library(Matrix)
library(MASS)
library(fmrs)
library(flexmix)
library(ggplot2)
library(corrplot)
library(dplyr)
library(reshape2)
library(latex2exp)
source("sim.r")
source("func.r")
source("estimate.r")
```


```{r}
n <- 200                         # The sample size
p <- 4                           # The dimension of x
q <- 3                         # The dimension of z
pq <- q*p                        # The dimension of each sample
dim_nonzero_beta <- 2                         # The dimension of non-zero coefficients of x
dim_nonzero_alpha <- 2                        # The dimension of non-zero coefficients of z
dim_nonzero_gamma <- 4
balance <- T                     # Balanced/Imbalanced subgroup
gr_num_main <- 2                     # The number of rough subgroup 
gr_num_sub <- 4                       # The number of refined subgroup 
hier_struc <- list(c(1,2),c(3,4))  # Hierarchical subgroup structure
# sd.epsi<-0.5                     # The residual error
# corZX <- F                       # Correlated/Uncorrelated X and Z
intercorr0<-"AR1"                # The correlation structure of Z
signal_its <- 2 # signal intensity
K <- gr_num_sub
iter_max <- 10
eps <- 0.001
incl_inter <- TRUE               # 模拟实验数据生成时候是否要包含交互项
tol <- 1e-5

lambda_1 <- 0
lambda_2 <- 0
lambda_3 <- 0
a <- 3
iter_max <- 20
K_up <- 4
tau <- 1 

# ------------ Necessary parameters to support algorithm implementation --------
comb_pair <- combn(K,2)
H_3 <- kronecker(Matrix(t(apply(comb_pair,2,dMatrixFun)),sparse = T),bdiag(diag(pq)))
H_1 <- kronecker(Matrix(t(apply(comb_pair,2,dMatrixFun)),sparse = T),bdiag(diag(p)))
H_2 <- kronecker(Matrix(t(apply(comb_pair,2,dMatrixFun)),sparse = T),bdiag(diag(q)))

# ------------ Generate the regression coefficients -----------
coef_main_value <- c(signal_its, -signal_its)
# coef_main_value <- c(signal_its, 2signal_its)
coef_sub_value <- c(1.5*signal_its, 0.5*signal_its, -0.5*signal_its, -1.5*signal_its)
# coef_sub_value <- c(1*signal_its, 2*signal_its, 3*signal_its, 4*signal_its)
if(balance){pr_sub<-rep(1/gr_num_sub,gr_num_sub)}else{pr_sub<-c(1/6,1/6,1/3,1/3)}

# true main groups & subgroups
set.seed(9)
ci <- ci_generate(n, pr_sub, hier_struc)
ci_sim <- rep(0, n) # true label
for(i in 1:K){
  ci_sim[ci$ci_sub[[i]]] <- i
}

# true coefficients
set.seed(9)
coef_true <- generate_coef_true(n, p, q, ci$ci_main, ci$ci_sub, 
                                coef_main_value,  coef_sub_value, incl_inter,
                                dim_nonzero_beta, dim_nonzero_alpha, dim_nonzero_gamma)
# Generate data
whole.data <- generate_sim_data(n, p, q, coef_true, cotype_x="AR_E", cotype_z="AR_E")
```


# Non-Zero Version

```{r}
# 等价相互计算
coef_eta2gamma <- function(coef, p, q){
  coef_beta <- coef[1:p,]
  coef_eta <- coef[(p+q+1):(p+q+p*q),]
  coef_gamma <- coef_eta / kronecker(matrix(1, nrow=q, ncol=1), coef_beta)
  return(rbind(coef[1:(p+q),], coef_gamma))
}
coef_gamma2eta <- function(coef, p, q){
  coef_beta <- coef[1:p,]
  coef_gamma <- coef[(p+q+1):(p+q+p*q),]
  coef_eta <- kronecker(matrix(1, nrow=q, ncol=1), coef_beta) * coef_gamma
  return(rbind(coef[1:(p+q),], coef_eta))
}
```



```{r}
p <- 2
q <- 2
x <- whole.data$X[,(1:p)]
z <- whole.data$Z[,(1:q)]
w <- matrix(0, n, p*q)
  for(i in 1:n){
    w[i,] <- kronecker(z[i,], x[i,])
  }
X <- cbind(x, z, w)
# 稠密真实参数
# 注意计算 y 时总要转化为 eta 版本
# coef_* 系列值总是 gamma 版本而非 eta
coef_true <- rbind(t(matrix(rep(c(2,2,-2,-2),4), 4)),
                   t(matrix(rep(c(3,1,-1,-3),4), 4)))
# y_true
y2 <- X %*% coef_gamma2eta(coef_true, p, q)
y <- NULL
for(i in 1:length(ci_sim)){ y[i] <- y2[i,ci_sim[i]] }
```

## fmrs

随机初始化也可以收敛到真值

注意直接用包得到的结果为 $\beta, \alpha, \eta$ 而非 $\gamma$

```{r}
K_up <- 4
xdim <- p+q+p*q
int_rm <- TRUE
as <- matrix(1, nrow = xdim+1, ncol = K_up) # activeset parameter in fmrs package
if (int_rm) { as[1, ] <- 0 }
# init of init
coef_init <- coef_true
set.seed(999)
coef_init <- coef_true + rnorm(length(coef_true))
coef_init <- coef_true - coef_true + rnorm(length(coef_true))
coef_rough_init <- rbind(matrix(0, nrow=1, ncol=K_up), coef_init)
res.mle <- fmrs.mle(y = y,
                  x = X,
                  delta = rep(1, n),
                  nComp = K_up,
                  disFamily = "norm",
                  initCoeff = coef_rough_init,
                  # initDispersion = rep(1, K_up),
                  initmixProp = rep(1 / K_up, K_up),
                  # nIterNR = 1000,
                  activeset = as)
coefficients(res.mle)
print("dispersion")
dispersion(res.mle)
print("mixprop")
mixProp(res.mle)
```


## flemix

效果不好

```{r}
colnames(X) <- paste0("X", 1:(xdim))
df_tmp <- cbind(data.frame(y=y), X)
model <- flexmix(y~0+., data = df_tmp, k = K_up) # 0 去除常数项
parameters(model)
```

## 准备

```{r}
coef_bind <- function(coef_beta, coef_alpha, coef_last){
  return(rbind(coef_beta, coef_alpha, coef_last))
}
coef_split <- function(coef, p, q){
  coef_beta <- coef[1:p,]
  coef_alpha <- coef[(p+1):(p+q),]
  coef_last <- coef[(p+q+1):(nrow(coef)),]
  return(list(coef_beta, coef_alpha, coef_last))
}
```

------------------------------- test part below ------------------------------------

```{r}
# 测试结束删除该模块
coef_est <- coef_true
# 和 fmrs 包用相同初值
# coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
rho_est <- 1/c(sd(y[ci_sim == 1]),sd(y[ci_sim == 2]),sd(y[ci_sim == 3]),sd(y[ci_sim == 4]))
rho_record <- list(rho_est)
coef_split_all <- coef_split(coef_est, p, q)
coef_beta <- coef_split_all[[1]]
coef_alpha <- coef_split_all[[2]]
coef_gamma <- coef_split_all[[3]]
coef_eta <- coef_split(coef_gamma2eta(coef_est, p, q), p, q)[[3]]
```


```{r}
# 结果 t(res) %*% beta_k 计算所有 beta_k 相关项
# 返回结果 n*1 矩阵
get_beta_var_fromlast <- function(wi, p, q, gamma_k_old){
  beta_var <- apply(matrix(wi*gamma_k_old, ncol = q), 1, sum)
  return(beta_var)
}
# gamma_k_old <- coef_gamma[,1]
# # res <- apply(whole.data$W, 1, get_beta_var, p, q, gamma_k_old)
# res <- apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old)
# t(res) %*% beta_k_old
```

```{r}
get_gamma_var_fromlast <- function(wi, p, q, beta_k_old){
  gamma_var <- as.numeric(wi * kronecker(matrix(1,nrow=q,ncol=1), beta_k_old))
  return(gamma_var)
}
# res <- apply(w, 1, get_gamma_var, p, q, beta_k_old)
# t(res) %*% gamma_k_old
```

检查以上两个计算 $X^\beta, X^\gamma$ 的方法是否正确

### 整体检验

```{r}
# eta 版本直接计算结果正确
p1 <- x %*% coef_beta
p2 <- z %*% coef_alpha
p3 <- w %*% coef_split(coef_est_v2, p, q)[[3]]
data.frame(p = p1 + p2 + p3,
           ci = ci_sim,
           y = y)
```

```{r}
data.frame(X %*% coef_est_v2, y, ci_sim)
```

### 检验 $\beta_k 相关系数计算正确性

- 如果 $X^\beta$ 计算正确，则在参数取真值时，类别内部有 $(X + t(X^\beta))\beta_k = y_k - Z\alpha_k$，无论真实归类为何，每个样本对于每个类别都有该式成立

- 如果 $X^\gamma$ 计算正确，则在参数取真值时，类别内部有 $t(X^\beta)\gamma_k = y_k - X\beta_k - Z\alpha_k$，无论真实归类为何，每个样本对于每个类别都有该式成立


```{r}
# 无论 k 取什么值，都应该完全相同
# 但是不可以直接用 = 判断，会有精确位数的差异
k <- 4
gamma_k_old <- coef_gamma[,k]
beta_k_old <- coef_beta[,k]
# p3_v2 <- get_beta_var_fromlast(w[1,], p, q, gamma_k_old)
p3_beta_x <- t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
p3_gamma_x <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
# 交互项的三种等价形式验证
data.frame(origin = p3[,k], 
           beta_v = p3_beta_x %*% coef_beta[,k], 
           gamma_v = p3_gamma_x %*% coef_gamma[,k],
           ci_sim, 
           dif = as.numeric(p3_beta_x %*% coef_beta[,k]) - p3[,k],
           same = round((p3_beta_x %*% coef_beta[,k]) - p3[,k]) == 0)
```

下面的验证由于涉及 y，而 y 与真实分类有关，所以只有归类正确时才有 `same=TRUE`

```{r}
k <- 2
gamma_k_old <- coef_gamma[,k]
beta_k_old <- coef_beta[,k]

res_beta <- t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
left_beta <- (x + res_beta) %*% coef_beta[,k]
right_beta <- y - z %*% coef_alpha[,k]
right_beta2 <- x%*%coef_beta[,k] + w%*%coef_eta[,k]
data.frame(left_beta, right_beta, right_beta2, 
           dif = round(left_beta-right_beta), 
           ci = ci_sim, 
           same = round(left_beta-right_beta)==0) %>% filter(ci == k)
```

### 检验 $\gamma_k 相关系数计算正确性


```{r}
k <- 2
gamma_k_old <- coef_gamma[,k]
beta_k_old <- coef_beta[,k]

res_gamma <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
left_gamma <- res_gamma %*% coef_gamma[,k]
right_gamma <- y - x %*% coef_beta[,k] - z %*% coef_alpha[,k]
data.frame(left_gamma, right_gamma, 
           dif = round(left_gamma-right_gamma), 
           ci = ci_sim, 
           same = round(left_gamma-right_gamma)==0) %>% filter(ci == k)
```


```{r}
k <- 4
gamma_k_old <- coef_gamma[,k]
beta_k_old <- coef_beta[,k]

# 需要重新计算交互项中 beta 相关 x 矩阵
# 因为此处未必与上面验证 beta 时为同一 k
res_beta <- t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
res_alpha <- z
left_alpha <- res_alpha %*% coef_alpha[,k]
right_alpha <- y - (x + res_beta) %*% coef_beta[,k]
data.frame(left_alpha, right_alpha, 
           dif = round(left_alpha-right_alpha), 
           ci = ci_sim, 
           same = round(left_alpha-right_alpha)==0) %>% filter(ci == k)
```



------------------------------------- test part above ----------------------------------------


## 单类迭代测试

只有一类时迭代求解 $\alpha_k, \beta_k, \gamma_k$

```{r}
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
```


```{r}
iter_max <- 200
k <- 2
sd <- .1
y_one <- y[ci_sim == k]

set.seed(999)
# 真值
coef_alpha_one <- coef_alpha_true[,k] 
coef_beta_one <- coef_beta_true[,k]
coef_gamma_one <- coef_gamma_true[,k]
# 真值基础上变动
coef_alpha_one <- coef_alpha_true[,k] + rnorm(1*p, mean = 0, sd = sd)
coef_beta_one <- coef_beta_true[,k] + rnorm(1*q, mean = 0, sd = sd)
coef_gamma_one <- coef_gamma_true[,k] + rnorm(1*p*q, mean = 0, sd = sd)
# 完全随机初始化
# coef_alpha_one <- coef_alpha_true[,k] - coef_alpha_true[,k] + rnorm(1*p, mean = 0, sd = sd)
# coef_beta_one <- coef_beta_true[,k] -  coef_beta_true[,k] + rnorm(1*q, mean = 0, sd = sd)
# coef_gamma_one <- coef_gamma_true[,k] - coef_gamma_true[,k] + rnorm(1*p*q, mean = 0, sd = sd)

coef_dist <- NULL
evs <- NULL
for(iter in 1:iter_max){
  ev <- NULL
  coef_old <- c(coef_alpha_one, coef_beta_one, coef_gamma_one)
  coef_dist[[iter]] <- sum((coef_alpha_true[,k]-coef_alpha_one)**2) + 
                             sum((coef_beta_true[,k]-coef_beta_one)**2) +
                              sum((coef_gamma_true[,k]-coef_gamma_one)**2)
  W <- diag(1, length(y_one))
  
  print(iter)
  print(matrix(c(coef_beta_one, coef_alpha_one, coef_gamma_one), ncol=1))
  
  
  # beta
  x_beta_k <- x[ci_sim == k,] + t(apply(w[ci_sim == k,], 1, get_beta_var_fromlast, p, q, coef_gamma_one))
  y_beta_k <- y_one - z[ci_sim == k,]%*%coef_alpha_one
  coef_beta_one <- solve(t(x_beta_k)%*%W%*%x_beta_k+diag(0.1,p))%*%t(x_beta_k)%*%W%*%y_beta_k

  # alpha
  x_alpha_k <- z[ci_sim == k,]
  y_alpha_k <- y_one - x_beta_k%*%coef_beta_one 
  coef_alpha_one <- solve(t(x_alpha_k)%*%W%*%x_alpha_k+diag(0.1,q))%*%t(x_alpha_k)%*%W%*%y_alpha_k
  
  
  # gamma
  x_gamma_k <- t(apply(w[ci_sim == k,], 1, get_gamma_var_fromlast, p, q, coef_beta_one))
  y_gamma_k <- y_one - x[ci_sim == k,]%*%coef_beta_one - z[ci_sim == k,]%*%coef_alpha_one
  coef_gamma_one <- solve(t(x_gamma_k)%*%W%*%x_gamma_k+diag(0.1,p*q))%*%t(x_gamma_k)%*%W%*%y_gamma_k
  
  ev <- c(ev, eigen(t(x_beta_k)%*%W%*%x_beta_k)$val)
  ev <- c(ev, eigen(t(x_alpha_k)%*%W%*%x_alpha_k)$val)
  ev <- c(ev, eigen(t(x_gamma_k)%*%W%*%x_gamma_k)$val)
  evs[[iter]] <- ev
  
  coef_cur <- c(coef_alpha_one, coef_beta_one, coef_gamma_one)
  if(sum((coef_cur - coef_old)**2) < 1e-5){
    print("converge with no coef change")
    return()
  }
}
plot(1:length(coef_dist), unlist(coef_dist), main = "Coef Distance (Est from True)",
     xlab = "Iteration", ylab = "Distance")
lapply(evs, min)
```

## 给定分类后计算

```{r}
q_c_matrix <- get_q_c_matrix(n, K_up, ci_sim)
sd_init <- .1
iter_max <- 100

coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]

# 基于正确答案进行干扰
coef_init <- coef_true

# 完全随机
set.seed(999)
coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = sd_init)

# 变化 beta
# set.seed(999)
# coef_init[1:p,] <- coef_init[1:p,] -
#    coef_init[1:p,] +
#    rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# # 变化 alpha
# set.seed(999)
# coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] -
#   coef_init[(p+1):(p+q),] +
#   rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# # 变化 gamma
# set.seed(999)
# coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
#   coef_init[(p+q+1):(p+q+p*q),] +
#   rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

# ******************************************************
# 测试此时单类的等价性
# k_one <- 4
# set.seed(999)
# # 真值
# coef_alpha_one <- coef_alpha_true[,k_one]
# coef_beta_one <- coef_beta_true[,k_one]
# coef_gamma_one <- coef_gamma_true[,k_one]
# # 真值基础上变动
# # coef_alpha_one <- coef_alpha_true[,k_one] + rnorm(1*p, mean = 0, sd = sd)
# # coef_beta_one <- coef_beta_true[,k_one] + rnorm(1*q, mean = 0, sd = sd)
# # coef_gamma_one <- coef_gamma_true[,k_one] + rnorm(1*p*q, mean = 0, sd = sd)
# # 完全随机初始化
# coef_alpha_one <- coef_alpha_true[,k_one] - coef_alpha_true[,k_one] + rnorm(1*p, mean = 0, sd = sd)
# coef_beta_one <- coef_beta_true[,k_one] -  coef_beta_true[,k_one] + rnorm(1*q, mean = 0, sd = sd)
# coef_gamma_one <- coef_gamma_true[,k_one] - coef_gamma_true[,k_one] + rnorm(1*p*q, mean = 0, sd = sd)
# 
# coef_init[,k_one] <- c(coef_beta_one, coef_alpha_one, coef_gamma_one)
# ******************************************************

# ******************************************************
# 多个类别都使用单类的初始
for(k_one in 1:K_up){
  set.seed(999)
  # 真值
  coef_alpha_one <- coef_alpha_true[,k_one]
  coef_beta_one <- coef_beta_true[,k_one]
  coef_gamma_one <- coef_gamma_true[,k_one]
  # 真值基础上变动
  coef_alpha_one <- coef_alpha_true[,k_one] + rnorm(1*p, mean = 0, sd = sd)
  coef_beta_one <- coef_beta_true[,k_one] + rnorm(1*q, mean = 0, sd = sd)
  coef_gamma_one <- coef_gamma_true[,k_one] + rnorm(1*p*q, mean = 0, sd = sd)
  # 完全随机初始化
  # coef_alpha_one <- coef_alpha_true[,k_one] - coef_alpha_true[,k_one] + rnorm(1*p, mean = 0, sd = sd)
  # coef_beta_one <- coef_beta_true[,k_one] -  coef_beta_true[,k_one] + rnorm(1*q, mean = 0, sd = sd)
  # coef_gamma_one <- coef_gamma_true[,k_one] - coef_gamma_true[,k_one] + rnorm(1*p*q, mean = 0, sd = sd)

  coef_init[,k_one] <- c(coef_beta_one, coef_alpha_one, coef_gamma_one)
}
# ******************************************************

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_dist <- sum((coef_est - coef_true)**2)
evs <- NULL
scs <- NULL

# print(coef_est)
for(iter in 2:iter_max){
  
  coef_old <- coef_est
  # *************************** 更新参数 ******************************
  coef_split_all <- coef_split(coef_est, p, q)
  coef_beta <- coef_split_all[[1]]
  # coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  coef_gamma <- coef_split_all[[3]]
  # coef_gamma <- coef_gamma_true
  
  evs[[iter]] <- matrix(0, nrow = p+q+p*q, ncol = 4)
  for (k in 1:K_up) {
  # for (k in k_one:k_one) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    # beta_k_old <- coef_beta[,k]
    
    # beta_k
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
    beta_k_old <- coef_beta[,k]
    
    # alpha_k
    x_alpha_k <- z
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k]
    coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    coef_alpha[,k] <- coef_alpha_k
    
    # gamma_k
     x_gamma_k <- t(apply(w[ci_sim == k,], 1, get_gamma_var_fromlast, p, q, coef_beta_one))
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    coef_gamma[,k] <- coef_gamma_k
    
    
    coef_est[,k] <- c(coef_beta[,k], coef_alpha[,k], coef_gamma[,k]) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
    # coef_est_v2[(p+q+1):(p+q+p*q),] <- coef_eta_true
    
    # 记录求逆阵的特征值
    # evs_k <- c(eigen(t(x_beta_k)%*%W%*%x_beta_k)$val,
    #            eigen(t(x_alpha_k)%*%W%*%x_alpha_k)$val,
    #            eigen(t(x_gamma_k)%*%W%*%x_gamma_k)$val)
    # evs[[iter]][,k] <- evs_k
  }
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  coef_dist[[iter]] <- sum((coef_est - coef_true)**2)
  # scs[[iter]] <- sc(ci_est, ci_sim)
  print(iter)
  print(coef_est)
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\alpha_k,\\beta_k,\\gamma_{k}$)"))
```







## 全类迭代

第一组实验无非零项，第二组实验有非零项

### 第一组-同 $\rho$

#### 只更新 $\alpha_k$ 固定 $\beta_k, \gamma_k$ 


```{r}
# 先退化为最简单的线性回归检查
y_copy <- y
```

```{r}
# 同 rho 版本 参考组，直接只更新 \alpha_k
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
y2 <- y_copy - x%*%coef_beta_true - w%*%coef_eta_true
# y2_tmp <- z%*%coef_alpha_true # 在正确的类别内二者等级 y2 == y2_tmp
y <- NULL
for(i in 1:length(ci_sim)){ y[i] <- y2[i,ci_sim[i]] }
```

```{r}
# 正常收敛，则如果 beta_k gamma_k 在迭代项中固定为真值也应该以相同的路径收敛
# 注意因为 alpha 实际只有两类，只要区分出 2 和 -2 即认为收敛到真值
iter_max <- 200
set.seed(999)
# 基于正确答案进行干扰
# alpha_init <- coef_alpha_true + rnorm(length(coef_alpha_true), mean = 0, sd = 1)
alpha_init <- coef_alpha_true - coef_alpha_true + rnorm(length(coef_alpha_true), mean = 0, sd = 1)
alpha_est <- alpha_init

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))
coef_dist <- sum((alpha_est - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (z%*%alpha_est))**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = z%*%alpha_est, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (z%*%alpha_est)[vanishidx, ])**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  alpha_old <- alpha_est
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    # alpha_k
    alpha_est_k <- solve(t(z)%*%W%*%z)%*%t(z)%*%W%*%y
    alpha_est[,k] <- alpha_est_k
  }
  rho_est <- rep(sqrt(n / sum((y - z%*%alpha_est)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((alpha_est - alpha_old)**2) < 1e-3){
    print('converge with no coef change')
    return()
  }
  print(iter)
  print(alpha_est)
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  coef_dist[iter] <- sum((alpha_est - coef_alpha_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, alpha_est, rho_est_list[[iter-1]]))
}
# plot(1:length(coef_dist), coef_dist) # 不正确，因为 K_up=4 而 alpha 的真实类别只有 2 类
```


```{r}
y <- y_copy
```

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
# set.seed(999)
# coef_init[1:p,] <- coef_init[1:p,] -
#   coef_init[1:p,] +
  # rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
set.seed(999)
coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - coef_init[(p+1):(p+q),]  +
  rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
# set.seed(999)
# coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
#   coef_init[(p+q+1):(p+q+p*q),] +
#   rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs <- NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2))**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ])**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  # coef_beta <- coef_split_all[[1]]
  coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  # coef_gamma <- coef_split_all[[3]]
  coef_gamma <- coef_gamma_true
  
  
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]
    
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    x_alpha_k <- z
    # x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k] # 间接证明 \beta_k 相关系数计算正确
    # y_alpha_k <- y - x%*%coef_beta[,k] - w%*%coef_eta_true[,k]
    # y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    # coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    # coef_beta[,k] <- coef_beta_k
    # alpha_k
    coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    # coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    # coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_true[,k], coef_alpha_k, coef_gamma_true[,k]) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  print(iter)
  print(coef_est[(p+1):(p+q),])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\alpha_{k}$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\alpha_{k}$)"))
```

#### 只更新 $\beta_k$ 固定 $\alpha_k, \gamma_k$ 

1. 直接计算，再次检查与 $\beta_k$ 相关参数计算是否正确

```{r}
# 完全真值一步求值
# 直接计算正确，说明 beta 相关的 x 系数提取正确
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
# coef_beta <- coef_split_all[[1]]
coef_beta <- coef_split_all[[1]] - coef_split_all[[1]]
coef_alpha <- coef_split_all[[2]]
coef_gamma <- coef_split_all[[3]]
coef_eta <- coef_split(coef_true_v2, p, q)[[3]]

q_c_matrix <- get_q_c_matrix(n, K_up, ci_sim)

for(k in 1:K_up){
  W <- diag(q_c_matrix[,k])
  gamma_k_old <- coef_gamma[,k]
  # beta_k_old <- coef_beta[,k]
  
  x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
  y_beta_k <- y - z%*%coef_alpha[,k]
  
  # beta_k
  coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
  coef_beta[,k] <- coef_beta_k
}
print(coef_beta)
```

2. 按照标准简单线性回归模型进行迭代验证


```{r}
iter_max <- 200
qc_eps <- 1e-5
y_beta <- y - z%*%coef_alpha
X_beta <- NULL

set.seed(999)
coef_beta <- matrix(rnorm(p*K_up, mean = 0, sd = 1), nrow = p, ncol = K_up)
# set.seed(999)
# coef_beta <- coef_beta_true + matrix(rnorm(p*K_up, mean = 0, sd = 1), nrow = p, ncol = K_up)
# coef_beta <- coef_beta_true

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

for(k in 1:K_up){
  X_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, coef_gamma_true[,k]))
  X_beta[[k]] <- X_beta_k
}

q_c_matrix <- matrix(0, nrow = n, ncol = K_up)
print(coef_beta)
for(iter in 2:2){
  for(k in 1:K_up){
    # 计算该类别的类别中心或距离相关
    if(iter == 2){
      q_c_matrix[,k] <- (1/(y_beta[,k] - X_beta[[k]]%*%coef_beta[,k])**2) * pi_est_list[[iter-1]][k]
    }else{
      dnorm(y_beta[,k], 
            mean = X_beta[[k]]%*%coef_beta[,k],
            sd = 1/mean(rho_est_list[[iter-1]])) * pi_est_list[[iter-1]][k]
    }
  }
  q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)

  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  print(iter)
  coef_old <- coef_beta
  for(k in 1:K_up){
    W <- diag(q_c_matrix[,k])
    x_beta_k <- X_beta[[k]]
    y_beta_k <- y_beta[,k]
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
  }
  print(coef_beta)
  rho_tmp <- matrix(0, nrow = n, ncol = K_up)
  for(k in 1:K_up){
    rho_tmp[,k] <- (y_beta[,k] - X_beta[[k]]%*%coef_beta[,k])**2 * q_c_matrix[,k]
  }
  rho_est <- rep(sqrt(n / sum(rho_tmp)), 4)
  rho_est_list[[iter]] <- rho_est
  ci_est <- apply(q_c_matrix, 1, which.max)
  print(sc(ci_est, ci_sim))
  # *************************** 判断收敛 ******************************
  if(sum((coef_beta - coef_old)**2) < 1e-10){
    print('converge with no coef change')
    return()
  }
}
```
```{r}
X_beta[[4]] %>% head()
y_beta[,4][1:6]
```



绘制最后一步迭代得到的

```{r}
plot_q_c <- function(q_c_matrix, save = FALSE, name = "plot_q_c_result"){
  ci_est <- apply(q_c_matrix, 1, which.max)
  q_c_plot <- data.frame(q_c_matrix)
  q_c_plot$ci <- ci_est
  q_c_plot$ci_sim <- ci_sim
  q_c_plot$id <- 1:200
  q_c_plot <- melt(q_c_plot, id.vars = c("id", "ci", "ci_sim")) %>% 
    arrange(ci_sim) %>%
    mutate(ci_id = paste0(ci_sim, "-", id))
  p <- ggplot(q_c_plot, aes(variable, ci_id)) +                           
    geom_tile(aes(fill = value)) +
    scale_fill_gradient(low = "white", high = "steelblue") +
    labs(y = "ci-id", x = "Class") +
    geom_hline(yintercept = c(sum(ci_sim == 1),
                              sum(ci_sim <= 2),
                              sum(ci_sim <= 3)), col = "red") +
    theme_bw()+
    theme(aspect.ratio=4/3,
          axis.text.y=element_text(size=2),
          axis.ticks.y = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank())
  if(save){ggsave(paste0(name, ".png"), dpi = 600, scale = 2)}
  return(p)
}
```

```{r}
plot_q_c(q_c_matrix, FALSE)
```


3. 回到正常流程

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
set.seed(999)
coef_init[1:p,] <- coef_init[1:p,] - 
  coef_init[1:p,] +
  rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
# set.seed(999)
# coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
#   coef_init[(p+1):(p+q),]  +
#   rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
# set.seed(999)
# coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
#   coef_init[(p+q+1):(p+q+p*q),] +
#   rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)
   
pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
evs <- NULL
scs <- NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
# for (iter in 2:2) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  coef_beta <- coef_split_all[[1]]
  # coef_beta <- coef_beta_true
  # coef_alpha <- coef_split_all[[2]]
  coef_alpha <- coef_alpha_true
  # coef_gamma <- coef_split_all[[3]]
  coef_gamma <- coef_gamma_true

  evs[[iter]] <- matrix(0, nrow = 2, ncol = 4)
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]

    # y_beta_k, x_beta_k 的两种计算方式都等价
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    # x_alpha_k <- z
    # x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    
    # y_alpha_k1 <- y - x_beta_k%*%coef_beta[,k]
    # y_alpha_k <- y - x%*%coef_beta[,k] - w%*%coef_eta_true[,k]
    # y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    evs_k <- eigen(t(x_beta_k)%*%W%*%x_beta_k)$val # 检查是否出现过小特征值
    evs[[iter]][,k] <- evs_k
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
    # alpha_k
    # coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    # coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    # coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    # coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_k, coef_alpha_true[,k], coef_gamma_true[,k]) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
    # coef_est_v2[(p+q+1):(p+q+p*q),] <- coef_eta_true
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  print(iter)
  print(coef_est[,])
  print(coef_est_v2)
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
# plot(1:length(coef_dist), coef_dist, 
#      xlab = "", ylab = "Coef Distance",
#      main = TeX("Coef Distance ($\\beta_{k}$)"))
# plot(2:length(scs), unlist(scs), 
#      xlab = "", ylab = "SC Score",
#      main = TeX("Subgrouping Consistency Score ($\\beta_{k}$)"))
```

```{r}
x_beta_k %>% head()
y_beta_k[1:6]
```


```{r}
plot_q_c(q_c_matrix, FALSE)
```


#### 只更新 $\gamma_k$ 固定 $\beta_k, \alpha_k$ 

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
# set.seed(999)
# coef_init[1:p,] <- coef_init[1:p,] -
#   coef_init[1:p,] +
#   rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
# set.seed(999)
# coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
#   coef_init[(p+1):(p+q),]  +
#   rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
set.seed(999)
coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
  coef_init[(p+q+1):(p+q+p*q),] +
  rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs < NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  # coef_beta <- coef_split_all[[1]]
  coef_beta <- coef_beta_true
  # coef_alpha <- coef_split_all[[2]]
  coef_alpha <- coef_alpha_true
  coef_gamma <- coef_split_all[[3]]
  # coef_gamma <- coef_gamma_true
  
  
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]
    
    # x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    # x_alpha_k <- z
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    # y_beta_k <- y - z%*%coef_alpha[,k]
    # y_alpha_k1 <- y - x_beta_k%*%coef_beta[,k]
    # y_alpha_k <- y - x%*%coef_beta[,k] - w%*%coef_eta_true[,k]
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    # coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    # coef_beta[,k] <- coef_beta_k
    # alpha_k
    # coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    # coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_true[,k], coef_alpha_true[,k], coef_gamma_k) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  # print(iter)
  print(coef_est[,])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\gamma_{k}$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\gamma_{k}$)"))
```

#### 更 $\alpha_k,\gamma_k$ 固定 $\beta_k$ 

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
# set.seed(999)
# coef_init[1:p,] <- coef_init[1:p,] -
#   coef_init[1:p,] +
#   rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
set.seed(999)
coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
  coef_init[(p+1):(p+q),]  +
  rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
set.seed(999)
coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
  coef_init[(p+q+1):(p+q+p*q),] +
  rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs <- NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  # coef_beta <- coef_split_all[[1]]
  coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  coef_gamma <- coef_split_all[[3]]
  # coef_gamma <- coef_gamma_true
  
  
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]
    
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    # x_alpha_k <- z
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    # y_beta_k <- y - z%*%coef_alpha[,k]
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k]
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    # coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    # coef_beta[,k] <- coef_beta_k
    # alpha_k
    coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_true[,k], coef_alpha_k, coef_gamma_k) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  # 暂时保留该条件
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  # print(iter)
  print(coef_est[,])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\alpha_{k},\\gamma_k$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\alpha_{k},\\gamma_k$)"))

```



#### 更 $\alpha_k,\beta_k$ 固定 $\gamma_k$ 

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
set.seed(999)
coef_init[1:p,] <- coef_init[1:p,] -
  coef_init[1:p,] +
  rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
set.seed(999)
coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
  coef_init[(p+1):(p+q),] +
  rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
# set.seed(999)
# coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
#   coef_init[(p+q+1):(p+q+p*q),]+
#   rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs <- NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  coef_beta <- coef_split_all[[1]]
  # coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  # coef_gamma <- coef_split_all[[3]]
  coef_gamma <- coef_gamma_true
  
  
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]
    
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    x_alpha_k <- z
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k]
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
    # alpha_k
    coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    # coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k+diag(0.1, p*q, p*q))%*%t(x_gamma_k)%*%W%*%y_gamma_k
    # coef_gamma[,k] <- coef_gamma_k
    
    # evs_k <- c(eigen(t(x_alpha_k)%*%W%*%x_alpha_k)$val, 
    #            eigen(t(x_beta_k)%*%W%*%x_beta_k)$val)
    # evs[[iter]][,k] <- evs_k
    
    coef_est[,k] <- c(coef_beta_k, coef_alpha_k, coef_gamma_true[,k]) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
    # coef_est_v2[(p+q+1):(p+q+p*q),] <- coef_eta_true
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  # 暂时保留该条件
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  # print(iter)
  print(coef_est[,])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\alpha_{k},\\beta_k$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\alpha_{k},\\beta_k$)"))
```

#### 更 $\beta_k,\gamma_k$ 固定 $\alpha_k$ 

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
set.seed(999)
coef_init[1:p,] <- coef_init[1:p,] - 
  coef_init[1:p,] +
  rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
# set.seed(999)
# coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
# coef_init[(p+1):(p+q),]  +
#   rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
set.seed(999)
coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
  coef_init[(p+q+1):(p+q+p*q),] +
  rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs <- NULL
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  coef_beta <- coef_split_all[[1]]
  # coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  # coef_gamma <- coef_split_all[[3]]
  coef_gamma <- coef_gamma_true
  
  
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    beta_k_old <- coef_beta[,k]
    
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    x_alpha_k <- z
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k]
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    
    # beta_k
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k+diag(0.1, p, p))%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
    # alpha_k
    # coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    # coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k+diag(0.1, p*q, p*q))%*%t(x_gamma_k)%*%W%*%y_gamma_k
    coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_k, coef_alpha_true[,k], coef_gamma_k) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
    # coef_est_v2[(p+q+1):(p+q+p*q),] <- coef_eta_true
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  # print(iter)
  print(coef_est[,])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\beta_k,\\gamma_{k}$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\beta_k,\\gamma_{k}$)"))
```


#### 更新所有

```{r}
# *****************************************************************
# 同 rho 版本
iter_max <- 200
sd_init <- 1
qc_eps <- 1e-5
set.seed(999)
coef_true_v2 <- coef_gamma2eta(coef_true, p, q)
coef_split_all <- coef_split(coef_true, p, q)
coef_beta_true <- coef_split_all[[1]]
coef_alpha_true <- coef_split_all[[2]]
coef_gamma_true <- coef_split_all[[3]]
coef_eta_true <- coef_split(coef_true_v2, p, q)[[3]]
# 完全随机
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 4)
# coef_init <- coef_true - coef_true + rnorm(length(coef_true), mean = 0, sd = 0.01)
# 基于正确答案进行干扰
coef_init <- coef_true
# 变化 beta
set.seed(999)
coef_init[1:p,] <- coef_init[1:p,] -
  coef_init[1:p,] +
  rnorm(length(coef_beta_true), mean = 0, sd = sd_init)
# 变化 alpha
set.seed(999)
coef_init[(p+1):(p+q),] <- coef_init[(p+1):(p+q),] - 
  coef_init[(p+1):(p+q),]  +
  rnorm(length(coef_alpha_true), mean = 0, sd = sd_init)
# 变化 gamma
set.seed(999)
coef_init[(p+q+1):(p+q+p*q),] <- coef_init[(p+q+1):(p+q+p*q),] -
  coef_init[(p+q+1):(p+q+p*q),] +
  rnorm(length(coef_gamma_true), mean = 0, sd = sd_init)

coef_est <- coef_init
coef_est_v2 <- coef_gamma2eta(coef_est, p, q)
coef_est_list <- list(coef_est)

pi_est <- rep(1/K_up, K_up)
pi_est_list <- list(pi_est)

rho_est_list <- list(c(1,1,1,1))

print(coef_est)
coef_dist <- sum((coef_est - coef_true)**2)
scs <- NULL
evs <- NULL
# 参数距离值应该等于 sum((coef_init[(p+1):(p+q),] - coef_alpha_true)**2)
for (iter in 2:iter_max) {
 
  # ********************* 更新后验概率矩阵 *********************
  if (iter == 2) {
    q_c_matrix <- t(t(matrix(1 / (y - (X %*% coef_est_v2) + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
  } else {
    q_c_matrix <- t(t(dnorm(y, mean = X %*% coef_est_v2, 
                            sd = 1 / mean(rho_est_list[[iter - 1]]))) * pi_est_list[[iter - 1]])
    q_c_matrix <- q_c_matrix / apply(q_c_matrix, 1, sum)
    vanishidx <- which(apply(q_c_matrix, 1, function(x) { sum(x) %>% is.na()}))
    if (!identical(vanishidx, integer(0))) {
      print(paste("******************", vanishidx, "****************"))
      # 若有密度消失样本，归为距离均值最近的类别
      # 应再处理 rho 暂时忽略这步
      q_c_matrix_addin <- t(t(matrix(1 / (y[vanishidx] - (X %*% coef_est_v2)[vanishidx, ] + qc_eps)**2, ncol = K_up)) * pi_est_list[[iter - 1]])
      q_c_matrix_addin <- q_c_matrix_addin / apply(q_c_matrix_addin, 1, sum)
      q_c_matrix[vanishidx, ] <- q_c_matrix_addin
    }
  }
  
  # *************************** 更新 pi ******************************
  pi_est <- apply(q_c_matrix, 2, sum) / n
  pi_est_list[[iter]] <- pi_est
  
  # *************************** 更新参数 ******************************
  coef_old <- coef_est
  coef_split_all <- coef_split(coef_est, p, q)
  coef_beta <- coef_split_all[[1]]
  # coef_beta <- coef_beta_true
  coef_alpha <- coef_split_all[[2]]
  # coef_alpha <- coef_alpha_true
  coef_gamma <- coef_split_all[[3]]
  # coef_gamma <- coef_gamma_true
  
  evs[[iter]] <- matrix(0, nrow = p+q+p*q, ncol = 4)
  for (k in 1:K_up) {
    W <- diag(q_c_matrix[,k])
    gamma_k_old <- coef_gamma[,k]
    # beta_k_old <- coef_beta[,k]
    
    evs_k <- c(eigen(t(x_beta_k)%*%W%*%x_beta_k)$val,
               eigen(t(x_alpha_k)%*%W%*%x_alpha_k)$val,
               eigen(t(x_gamma_k)%*%W%*%x_gamma_k)$val)
    evs[[iter]][,k] <- evs_k
    
    # beta_k
    x_beta_k <- x + t(apply(w, 1, get_beta_var_fromlast, p, q, gamma_k_old))
    y_beta_k <- y - z%*%coef_alpha[,k]
    coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k)%*%t(x_beta_k)%*%W%*%y_beta_k
    coef_beta[,k] <- coef_beta_k
    beta_k_old <- coef_beta[,k]
    # alpha_k
    x_alpha_k <- z
    y_alpha_k <- y - x_beta_k%*%coef_beta[,k]
    coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k)%*%t(x_alpha_k)%*%W%*%y_alpha_k
    coef_alpha[,k] <- coef_alpha_k
    # gamma_k
    x_gamma_k <- t(apply(w, 1, get_gamma_var_fromlast, p, q, beta_k_old))
    y_gamma_k <- y - x%*%coef_beta[,k] - z%*%coef_alpha[,k]
    coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k)%*%t(x_gamma_k)%*%W%*%y_gamma_k
    coef_gamma[,k] <- coef_gamma_k
    
    # coef_beta_k <- solve(t(x_beta_k)%*%W%*%x_beta_k+diag(0.1, p, p))%*%t(x_beta_k)%*%W%*%y_beta_k
    # coef_beta[,k] <- coef_beta_k
    # # alpha_k
    # coef_alpha_k <- solve(t(x_alpha_k)%*%W%*%x_alpha_k+diag(0.1, q, q))%*%t(x_alpha_k)%*%W%*%y_alpha_k
    # coef_alpha[,k] <- coef_alpha_k
    # # gamma_k
    # coef_gamma_k <- solve(t(x_gamma_k)%*%W%*%x_gamma_k+diag(0.1, p*q, p*q))%*%t(x_gamma_k)%*%W%*%y_gamma_k
    # coef_gamma[,k] <- coef_gamma_k
    
    coef_est[,k] <- c(coef_beta_k, coef_alpha_true[,k], coef_gamma_k) # 注意本次只更新了其中第 k 列
    coef_est_v2 <- coef_gamma2eta(coef_est, p, q) # 注意本次只更新了其中第 k 列
    # coef_est_v2[(p+q+1):(p+q+p*q),] <- coef_eta_true
  }
  rho_est <- rep(sqrt(n / sum((y - X %*% coef_est_v2)**2 * q_c_matrix)), 4)
  rho_est_list[[iter]] <- rho_est
  
  # *************************** 判断收敛 ******************************
  if(sum((coef_est - coef_old)**2) < 1e-5){
    print('converge with no coef change')
    return()
  }
  # print(iter)
  print(coef_est[,])
  # print(rho_est)
  ci_est <- apply(q_c_matrix, 1, which.max)
  scs[[iter]] <- sc(ci_est, ci_sim)
  coef_dist[iter] <- sum((coef_est - coef_true)**2)
  # print(right_class_ratio(ci_sim, ci_est))
  # print(plot_classdis(1, coef_est_v2, rho_est_list[[iter-1]]))
}
plot(1:length(coef_dist), coef_dist, 
     xlab = "", ylab = "Coef Distance",
     main = TeX("Coef Distance ($\\alpha_k,\\beta_k,\\gamma_{k}$)"))
plot(2:length(scs), unlist(scs), 
     xlab = "", ylab = "SC Score",
     main = TeX("Subgrouping Consistency Score ($\\alpha_k,\\beta_k,\\gamma_{k}$)"))
```




















